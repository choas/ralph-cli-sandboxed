import { existsSync, writeFileSync, mkdirSync, chmodSync } from "fs";
import { join, basename } from "path";
import { spawn } from "child_process";
import { loadConfig, getRalphDir } from "../utils/config.js";
import { promptConfirm } from "../utils/prompt.js";
import { getLanguagesJson, getCliProvidersJson } from "../templates/prompts.js";

const DOCKER_DIR = "docker";

// Get language Docker snippet from config, with version substitution
function getLanguageSnippet(language: string, javaVersion?: number): string {
  const languagesJson = getLanguagesJson();
  const langConfig = languagesJson.languages[language];

  if (!langConfig || !langConfig.docker) {
    return "# Custom language - add your dependencies here";
  }

  let snippet = langConfig.docker.install;

  // Replace ${version} placeholder with actual version
  if (langConfig.docker.versionConfigurable && javaVersion) {
    snippet = snippet.replace(/\$\{version\}/g, String(javaVersion));
  } else if (langConfig.docker.version) {
    snippet = snippet.replace(/\$\{version\}/g, String(langConfig.docker.version));
  }

  return "\n" + snippet + "\n";
}

// Get CLI provider Docker snippet from config
function getCliProviderSnippet(cliProvider?: string): string {
  const cliProvidersJson = getCliProvidersJson();
  const providerKey = cliProvider || "claude";
  const provider = cliProvidersJson.providers[providerKey];

  if (!provider || !provider.docker) {
    // Default to Claude Code CLI if provider not found
    return "# Install Claude Code CLI\nRUN curl -fsSL https://claude.ai/install.sh | bash";
  }

  return provider.docker.install;
}

function generateDockerfile(language: string, javaVersion?: number, cliProvider?: string): string {
  const languageSnippet = getLanguageSnippet(language, javaVersion);
  const cliSnippet = getCliProviderSnippet(cliProvider);

  return `# Ralph CLI Sandbox Environment
# Based on Claude Code devcontainer
# Generated by ralph-cli

FROM node:20-bookworm

ARG DEBIAN_FRONTEND=noninteractive
ARG TZ=UTC
ARG ZSH_IN_DOCKER_VERSION="1.2.1"

# Set timezone
ENV TZ=\${TZ}
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    git \\
    curl \\
    wget \\
    nano \\
    vim \\
    less \\
    procps \\
    sudo \\
    man-db \\
    unzip \\
    gnupg2 \\
    jq \\
    fzf \\
    iptables \\
    ipset \\
    iproute2 \\
    dnsutils \\
    zsh \\
    && rm -rf /var/lib/apt/lists/*

# Setup zsh with oh-my-zsh and plugins (no theme, we set custom prompt)
RUN sh -c "$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v\${ZSH_IN_DOCKER_VERSION}/zsh-in-docker.sh)" -- \\
    -t "" \\
    -p git \\
    -p fzf \\
    -a "source /usr/share/doc/fzf/examples/key-bindings.zsh 2>/dev/null || true" \\
    -a "source /usr/share/doc/fzf/examples/completion.zsh 2>/dev/null || true" \\
    -a "export HISTFILE=/commandhistory/.zsh_history" \\
    -a 'alias ll="ls -la"'

# Set custom prompt for node user (after oh-my-zsh to avoid override)
RUN cp -r /root/.oh-my-zsh /home/node/.oh-my-zsh && chown -R node:node /home/node/.oh-my-zsh && \\
    cp /root/.zshrc /home/node/.zshrc && chown node:node /home/node/.zshrc && \\
    sed -i 's|/root/.oh-my-zsh|/home/node/.oh-my-zsh|g' /home/node/.zshrc && \\
    echo 'PROMPT="%K{yellow}%F{black}[ralph]%f%k%K{yellow}%F{black}%d%f%k\\$ "' >> /home/node/.zshrc && \\
    echo '' >> /home/node/.zshrc && \\
    echo '# Ralph ASCII art banner' >> /home/node/.zshrc && \\
    echo 'if [ -z "$RALPH_BANNER_SHOWN" ]; then' >> /home/node/.zshrc && \\
    echo '  export RALPH_BANNER_SHOWN=1' >> /home/node/.zshrc && \\
    echo '  echo ""' >> /home/node/.zshrc && \\
    echo '  echo " ____      _    _     ____  _   _ "' >> /home/node/.zshrc && \\
    echo '  echo "|  _ \\\\    / \\\\  | |   |  _ \\\\| | | |"' >> /home/node/.zshrc && \\
    echo '  echo "| |_) |  / _ \\\\ | |   | |_) | |_| |"' >> /home/node/.zshrc && \\
    echo '  echo "|  _ <  / ___ \\\\| |___|  __/|  _  |"' >> /home/node/.zshrc && \\
    echo '  echo "|_| \\\\_\\\\/_/   \\\\_\\\\_____|_|   |_| |_|"' >> /home/node/.zshrc && \\
    echo '  echo ""' >> /home/node/.zshrc && \\
    echo '  RALPH_VERSION=$(ralph --version 2>/dev/null | head -1 || echo "unknown")' >> /home/node/.zshrc && \\
    echo '  echo "CLI - Version $RALPH_VERSION"' >> /home/node/.zshrc && \\
    echo '  echo ""' >> /home/node/.zshrc && \\
    echo 'fi' >> /home/node/.zshrc

${cliSnippet}

# Install ralph-cli-sandboxed from npm registry
RUN npm install -g ralph-cli-sandboxed
${languageSnippet}
# Setup sudo only for firewall script (no general sudo for security)
RUN echo "node ALL=(ALL) NOPASSWD: /usr/local/bin/init-firewall.sh" >> /etc/sudoers.d/node-firewall

# Create directories
RUN mkdir -p /workspace && chown node:node /workspace
RUN mkdir -p /home/node/.claude && chown node:node /home/node/.claude
RUN mkdir -p /commandhistory && chown node:node /commandhistory

# Copy firewall script
COPY init-firewall.sh /usr/local/bin/init-firewall.sh
RUN chmod +x /usr/local/bin/init-firewall.sh

# Set environment variables
ENV DEVCONTAINER=true
ENV NODE_OPTIONS="--max-old-space-size=4096"
ENV CLAUDE_CONFIG_DIR="/home/node/.claude"
ENV SHELL=/bin/zsh
ENV EDITOR=nano

# Add bash aliases and prompt (fallback if using bash)
RUN echo 'alias ll="ls -la"' >> /etc/bash.bashrc && \\
    echo 'PS1="\\[\\033[43;30m\\][ralph]\\w\\[\\033[0m\\]\\$ "' >> /etc/bash.bashrc

# Switch to non-root user
USER node
WORKDIR /workspace

# Default to zsh
CMD ["zsh"]
`;
}

const FIREWALL_SCRIPT = `#!/bin/bash
# Firewall initialization script for Ralph sandbox
# Based on Claude Code devcontainer firewall

set -e

echo "Initializing sandbox firewall..."

# Get Docker DNS before flushing
DOCKER_DNS=$(cat /etc/resolv.conf | grep nameserver | head -1 | awk '{print $2}')

# Flush existing rules
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X

# Create ipset for allowed IPs
ipset destroy allowed_ips 2>/dev/null || true
ipset create allowed_ips hash:net

# Allow localhost
iptables -A OUTPUT -o lo -j ACCEPT
iptables -A INPUT -i lo -j ACCEPT

# Allow established connections
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Allow DNS
iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT
if [ -n "$DOCKER_DNS" ]; then
    iptables -A OUTPUT -d $DOCKER_DNS -j ACCEPT
fi

# Allow SSH (for git)
iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT

# Add allowed domains to ipset
# GitHub
for ip in $(dig +short github.com api.github.com raw.githubusercontent.com); do
    ipset add allowed_ips $ip 2>/dev/null || true
done

# npm registry
for ip in $(dig +short registry.npmjs.org); do
    ipset add allowed_ips $ip 2>/dev/null || true
done

# Anthropic API
for ip in $(dig +short api.anthropic.com); do
    ipset add allowed_ips $ip 2>/dev/null || true
done

# Allow host network (for mounted volumes, etc.)
HOST_NETWORK=$(ip route | grep default | awk '{print $3}' | head -1)
if [ -n "$HOST_NETWORK" ]; then
    HOST_SUBNET=$(echo $HOST_NETWORK | sed 's/\\.[0-9]*$/.0\\/24/')
    ipset add allowed_ips $HOST_SUBNET 2>/dev/null || true
fi

# Allow traffic to allowed IPs
iptables -A OUTPUT -m set --match-set allowed_ips dst -j ACCEPT

# Set default policies to DROP
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP

# Allow HTTPS to allowed IPs
iptables -I OUTPUT -p tcp --dport 443 -m set --match-set allowed_ips dst -j ACCEPT
iptables -I OUTPUT -p tcp --dport 80 -m set --match-set allowed_ips dst -j ACCEPT

echo "Firewall initialized. Only allowed destinations are accessible."
echo "Allowed: GitHub, npm, Anthropic API, local network"
`;

function generateDockerCompose(imageName: string): string {
  return `# Ralph CLI Docker Compose
# Generated by ralph-cli

services:
  ralph:
    image: ${imageName}
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      # Mount project root (two levels up from .ralph/docker/)
      - ../..:/workspace
      # Mount host's ~/.claude for Pro/Max OAuth credentials
      - \${HOME}/.claude:/home/node/.claude
      - ${imageName}-history:/commandhistory
    # Uncomment to use API key instead of OAuth:
    # environment:
    #   - ANTHROPIC_API_KEY=\${ANTHROPIC_API_KEY}
    working_dir: /workspace
    stdin_open: true
    tty: true
    cap_add:
      - NET_ADMIN  # Required for firewall
    # Uncomment to enable firewall sandboxing:
    # command: bash -c "sudo /usr/local/bin/init-firewall.sh && zsh"

volumes:
  ${imageName}-history:
`;
}

const DOCKERIGNORE = `# Docker ignore file
node_modules
dist
.git
*.log
`;

async function generateFiles(ralphDir: string, language: string, imageName: string, force: boolean = false, javaVersion?: number, cliProvider?: string): Promise<void> {
  const dockerDir = join(ralphDir, DOCKER_DIR);

  // Create docker directory
  if (!existsSync(dockerDir)) {
    mkdirSync(dockerDir, { recursive: true });
    console.log(`Created ${DOCKER_DIR}/`);
  }

  const files = [
    { name: "Dockerfile", content: generateDockerfile(language, javaVersion, cliProvider) },
    { name: "init-firewall.sh", content: FIREWALL_SCRIPT },
    { name: "docker-compose.yml", content: generateDockerCompose(imageName) },
    { name: ".dockerignore", content: DOCKERIGNORE },
  ];

  for (const file of files) {
    const filePath = join(dockerDir, file.name);

    if (existsSync(filePath) && !force) {
      const overwrite = await promptConfirm(`${DOCKER_DIR}/${file.name} already exists. Overwrite?`);
      if (!overwrite) {
        console.log(`Skipped ${file.name}`);
        continue;
      }
    }

    writeFileSync(filePath, file.content);

    if (file.name.endsWith(".sh")) {
      chmodSync(filePath, 0o755);
    }

    console.log(`Created ${DOCKER_DIR}/${file.name}`);
  }
}

async function buildImage(ralphDir: string): Promise<void> {
  const dockerDir = join(ralphDir, DOCKER_DIR);

  if (!existsSync(join(dockerDir, "Dockerfile"))) {
    console.error("Dockerfile not found. Run 'ralph docker' first.");
    process.exit(1);
  }

  console.log("Building Docker image...\n");

  return new Promise((resolve, reject) => {
    // Use --no-cache and --pull to ensure we always get the latest CLI versions
    const proc = spawn("docker", ["compose", "build", "--no-cache", "--pull"], {
      cwd: dockerDir,
      stdio: "inherit",
    });

    proc.on("close", (code) => {
      if (code === 0) {
        console.log("\nDocker image built successfully!");
        resolve();
      } else {
        reject(new Error(`Docker build failed with code ${code}`));
      }
    });

    proc.on("error", (err) => {
      reject(new Error(`Failed to run docker: ${err.message}`));
    });
  });
}

async function imageExists(imageName: string): Promise<boolean> {
  return new Promise((resolve) => {
    const proc = spawn("docker", ["images", "-q", imageName], {
      stdio: ["ignore", "pipe", "ignore"],
    });

    let output = "";
    proc.stdout.on("data", (data) => {
      output += data.toString();
    });

    proc.on("close", () => {
      // If output is non-empty, image exists
      resolve(output.trim().length > 0);
    });

    proc.on("error", () => {
      resolve(false);
    });
  });
}

async function runContainer(ralphDir: string, imageName: string, language: string, javaVersion?: number, cliProvider?: string): Promise<void> {
  const dockerDir = join(ralphDir, DOCKER_DIR);
  const dockerfileExists = existsSync(join(dockerDir, "Dockerfile"));
  const hasImage = await imageExists(imageName);

  // Auto-init and build if docker folder or image doesn't exist
  if (!dockerfileExists || !hasImage) {
    if (!dockerfileExists) {
      console.log("Docker folder not found. Initializing docker setup...\n");
      await generateFiles(ralphDir, language, imageName, true, javaVersion, cliProvider);
      console.log("");
    }

    if (!hasImage) {
      console.log("Docker image not found. Building image...\n");
      await buildImage(ralphDir);
      console.log("");
    }
  }

  console.log("Starting Docker container...\n");

  return new Promise((resolve, reject) => {
    const proc = spawn("docker", ["compose", "run", "--rm", "ralph"], {
      cwd: dockerDir,
      stdio: "inherit",
    });

    proc.on("close", (code) => {
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(`Docker run failed with code ${code}`));
      }
    });

    proc.on("error", (err) => {
      reject(new Error(`Failed to run docker: ${err.message}`));
    });
  });
}

async function cleanImage(imageName: string, ralphDir: string): Promise<void> {
  const dockerDir = join(ralphDir, DOCKER_DIR);

  console.log(`Cleaning Docker image: ${imageName}...\n`);

  // First, stop any running containers via docker compose
  if (existsSync(join(dockerDir, "docker-compose.yml"))) {
    // Stop running containers first
    await new Promise<void>((resolve) => {
      const proc = spawn("docker", ["compose", "stop", "--timeout", "5"], {
        cwd: dockerDir,
        stdio: "inherit",
      });

      proc.on("close", () => {
        resolve();
      });

      proc.on("error", () => {
        resolve();
      });
    });

    // Remove containers, volumes, networks, and local images
    await new Promise<void>((resolve) => {
      const proc = spawn("docker", ["compose", "down", "--rmi", "local", "-v", "--remove-orphans", "--timeout", "5"], {
        cwd: dockerDir,
        stdio: "inherit",
      });

      proc.on("close", () => {
        // Continue regardless of exit code (image may not exist)
        resolve();
      });

      proc.on("error", () => {
        resolve();
      });
    });
  }

  // Find and forcibly remove any containers using volumes with our image name pattern
  // This handles orphaned containers from previous runs or pods
  const volumePattern = `docker_${imageName}`;
  await new Promise<void>((resolve) => {
    // List all containers (including stopped) and filter by volume name pattern
    const proc = spawn("docker", ["ps", "-aq", "--filter", `volume=${volumePattern}`], {
      stdio: ["ignore", "pipe", "ignore"],
    });

    let output = "";
    proc.stdout.on("data", (data) => {
      output += data.toString();
    });

    proc.on("close", async () => {
      const containerIds = output.trim().split("\n").filter((id) => id.length > 0);
      if (containerIds.length > 0) {
        // Force remove these containers
        await new Promise<void>((innerResolve) => {
          const rmProc = spawn("docker", ["rm", "-f", ...containerIds], {
            stdio: "inherit",
          });
          rmProc.on("close", () => innerResolve());
          rmProc.on("error", () => innerResolve());
        });
      }
      resolve();
    });

    proc.on("error", () => {
      resolve();
    });
  });

  // Also try to remove the image directly (in case it was built outside compose)
  await new Promise<void>((resolve) => {
    const proc = spawn("docker", ["rmi", "-f", imageName], {
      stdio: "inherit",
    });

    proc.on("close", () => {
      resolve();
    });

    proc.on("error", () => {
      resolve();
    });
  });

  // Clean up volumes matching our pattern
  await new Promise<void>((resolve) => {
    // List volumes matching our pattern
    const proc = spawn("docker", ["volume", "ls", "-q", "--filter", `name=${volumePattern}`], {
      stdio: ["ignore", "pipe", "ignore"],
    });

    let output = "";
    proc.stdout.on("data", (data) => {
      output += data.toString();
    });

    proc.on("close", async () => {
      const volumeNames = output.trim().split("\n").filter((name) => name.length > 0);
      if (volumeNames.length > 0) {
        // Force remove these volumes
        await new Promise<void>((innerResolve) => {
          const rmProc = spawn("docker", ["volume", "rm", "-f", ...volumeNames], {
            stdio: "inherit",
          });
          rmProc.on("close", () => innerResolve());
          rmProc.on("error", () => innerResolve());
        });
      }
      resolve();
    });

    proc.on("error", () => {
      resolve();
    });
  });

  // Also try removing the simple volume name pattern
  const volumeName = `${imageName}-history`;
  await new Promise<void>((resolve) => {
    const proc = spawn("docker", ["volume", "rm", "-f", volumeName], {
      stdio: "inherit",
    });

    proc.on("close", () => {
      resolve();
    });

    proc.on("error", () => {
      resolve();
    });
  });

  // For Podman: clean up any orphaned pods matching this specific project
  // Use imageName to ensure we only clean this project's pods, not other ralph projects
  await new Promise<void>((resolve) => {
    const proc = spawn("docker", ["pod", "ls", "-q", "--filter", `name=${imageName}`], {
      stdio: ["ignore", "pipe", "ignore"],
    });

    let output = "";
    proc.stdout.on("data", (data) => {
      output += data.toString();
    });

    proc.on("close", async () => {
      const podIds = output.trim().split("\n").filter((id) => id.length > 0);
      if (podIds.length > 0) {
        // Force remove these pods (this also removes their containers)
        await new Promise<void>((innerResolve) => {
          const rmProc = spawn("docker", ["pod", "rm", "-f", ...podIds], {
            stdio: "inherit",
          });
          rmProc.on("close", () => innerResolve());
          rmProc.on("error", () => innerResolve());
        });
      }
      resolve();
    });

    proc.on("error", () => {
      // docker pod command doesn't exist (not Podman) - ignore
      resolve();
    });
  });

  // Clean up project-specific network (named after imageName, not generic docker_default)
  const networkName = `docker_${imageName}_default`;
  await new Promise<void>((resolve) => {
    const proc = spawn("docker", ["network", "rm", networkName], {
      stdio: ["ignore", "ignore", "ignore"], // Suppress output - network may not exist
    });

    proc.on("close", () => {
      resolve();
    });

    proc.on("error", () => {
      resolve();
    });
  });

  console.log("\nDocker image and associated resources cleaned.");
  console.log("Run 'ralph docker build' to rebuild the image.");
}

export async function docker(args: string[]): Promise<void> {
  const subcommand = args[0];
  const subArgs = args.slice(1);

  // Show help without requiring init
  if (subcommand === "help" || subcommand === "--help" || subcommand === "-h") {
    console.log(`
ralph docker - Generate and manage Docker sandbox environment

USAGE:
  ralph docker init         Generate Dockerfile and scripts
  ralph docker init -y      Generate files, overwrite without prompting
  ralph docker build        Build image (fetches latest CLI versions)
  ralph docker build --clean  Clean existing image and rebuild from scratch
  ralph docker run          Run container (auto-init and build if needed)
  ralph docker clean        Remove Docker image and associated resources
  ralph docker help         Show this help message

FILES GENERATED:
  .ralph/docker/
  ├── Dockerfile            Based on Claude Code devcontainer
  ├── init-firewall.sh      Sandbox firewall script
  ├── docker-compose.yml    Container orchestration
  └── .dockerignore         Build exclusions

AUTHENTICATION:
  Pro/Max users: Your ~/.claude credentials are mounted automatically.
  API key users: Uncomment ANTHROPIC_API_KEY in docker-compose.yml.

EXAMPLES:
  ralph docker init               # Generate files
  ralph docker build              # Build image
  ralph docker build --clean      # Clean and rebuild from scratch
  ralph docker run                # Start interactive shell
  ralph docker clean              # Remove image and volumes

  # Or use docker compose directly:
  cd .ralph/docker && docker compose run --rm ralph

  # Run ralph automation in container:
  docker compose run --rm ralph ralph once

INSTALLING PACKAGES (works with Docker & Podman):
  # 1. Run as root to install packages:
  docker compose run -u root ralph apt-get update
  docker compose run -u root ralph apt-get install <package>

  # 2. Or commit changes to a new image:
  docker run -it --name temp -u root <image> bash
  # inside: apt-get update && apt-get install <package>
  # exit, then:
  docker commit temp <image>:custom
  docker rm temp
`);
    return;
  }

  const ralphDir = getRalphDir();

  if (!existsSync(ralphDir)) {
    console.error("Error: .ralph/ directory not found. Run 'ralph init' first.");
    process.exit(1);
  }

  const config = loadConfig();

  // Get image name from config or generate default
  const imageName = config.imageName || `ralph-${basename(process.cwd()).toLowerCase().replace(/[^a-z0-9-]/g, "-")}`;

  const hasFlag = (flag: string): boolean => subArgs.includes(flag);

  switch (subcommand) {
    case "build":
      // Handle build --clean combination: clean first, then build
      if (hasFlag("--clean")) {
        await cleanImage(imageName, ralphDir);
        console.log(""); // Add spacing between clean and build output
      }
      await buildImage(ralphDir);
      break;

    case "run":
      await runContainer(ralphDir, imageName, config.language, config.javaVersion, config.cliProvider);
      break;

    case "clean":
      await cleanImage(imageName, ralphDir);
      break;

    case "init":
    default: {
      // Default to init if no subcommand or unrecognized subcommand
      const force = subcommand === "init"
        ? (subArgs[0] === "-y" || subArgs[0] === "--yes")
        : (subcommand === "-y" || subcommand === "--yes");
      console.log(`Generating Docker files for: ${config.language}`);
      if ((config.language === "java" || config.language === "kotlin") && config.javaVersion) {
        console.log(`Java version: ${config.javaVersion}`);
      }
      if (config.cliProvider && config.cliProvider !== "claude") {
        console.log(`CLI provider: ${config.cliProvider}`);
      }
      console.log(`Image name: ${imageName}\n`);
      await generateFiles(ralphDir, config.language, imageName, force, config.javaVersion, config.cliProvider);

      console.log(`
Docker files generated in .ralph/docker/

Next steps:
  1. Build the image: ralph docker build
  2. Run container:    ralph docker run

Or use docker compose directly:
  cd .ralph/docker && docker compose run --rm ralph
`);
      break;
    }
  }
}
